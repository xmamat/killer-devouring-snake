<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8' />
  <title>Killer Devouring Snake</title>
  <style type='text/css'>
    canvas {
      background-color: black;
    }
  </style>
</head>

<body onload="play()">
  <canvas id='canvas' width='480' height='480'></canvas>
  <div>
    <button onclick="options.togglePlayer()" id='togglePlayer'></button>
    <button onclick="options.speedDown()" id='speedDown'>speed down</button>
    <button onclick="options.speedUp()" id='speedUp'>speed up</button>
    <button onclick="options.toggleShowSnakeIndices()" id='toggleShowSnakeIndices'></button>
    <button onclick="options.toggleShowHamiltonianIndices()" id='toggleShowHamiltonianIndices'></button>
    <button onclick="options.toggleHamiltonianShortcuts()" id='toggleHamiltonianShortcuts'></button>
  </div>
  <div>
    run #<label id='runNumber'></label>
  </div>
  <div>
    score: <label id='currentScore'></label>
  </div>
  <div>
    move count: <label id='currentMoveCount'></label>
  </div>
  <div>
    mean score: <label id='meanScore'></label>
  </div>
  <div>
    mean move count: <label id='meanMoveCount'></label>
  </div>
  <div>
    win rate: <label id='winRate'></label>
  </div>
</body>
<script type='text/javascript'>
  var canvas = document.getElementById('canvas');
  var context = canvas.getContext('2d');

  function play() {
    var reset = () => {
      board.clear();
      snake.start();
      board.spawnFruit();
    };
    reset();

    var loop = () => {
      snake.decide();
      snake.move();
      if (snake.collided || snake.wins()) {
        reset();
        statistics.refresh();
      }
      options.display();
      statistics.display();
      board.render();

      setTimeout(loop, options.turnIntervalInMilliseconds);
    };
    loop();
  }

  var options = {
    player: 'ai',
    turnIntervalInMilliseconds: 100,
    showHamiltonianIndices: false,
    showSnakeIndices: false,
    enableHamiltonianShortcuts: true,
    
    togglePlayer() {
      this.player = this.player === 'ai' ? 'human' : 'ai';
      if (this.player === 'ai') {
        window.removeEventListener('keydown', snake.listen);
      } else {
        window.addEventListener('keydown', snake.listen);
      }
    },

    speedDown() {
      this.turnIntervalInMilliseconds *= 2;
    },

    speedUp() {
      this.turnIntervalInMilliseconds /= 2;
    },

    toggleShowSnakeIndices() {
      this.showSnakeIndices = !this.showSnakeIndices;
    },

    toggleShowHamiltonianIndices() {
      this.showHamiltonianIndices = !this.showHamiltonianIndices;
    },

    toggleHamiltonianShortcuts() {
      this.enableHamiltonianShortcuts = !this.enableHamiltonianShortcuts;
    },

    display() {
      document.getElementById('togglePlayer').innerHTML = this.player === 'ai' ?  "let me play" : "let AI play";
      document.getElementById('toggleShowSnakeIndices').innerHTML = this.showSnakeIndices ?  "hide snake indices" : "show snake indices";
      document.getElementById('toggleShowHamiltonianIndices').innerHTML = this.showHamiltonianIndices ?  "hide Hamiltonian indices" : "show Hamiltonian indices";
      if (this.player === 'ai') {
        document.getElementById('toggleHamiltonianShortcuts').innerHTML = this.enableHamiltonianShortcuts ?  "disable Hamiltonian shortcuts" : "enable Hamiltonian shortcuts";
        document.getElementById('toggleHamiltonianShortcuts').style.display = 'block';
      } else {
        document.getElementById('toggleHamiltonianShortcuts').style.display = 'none';
      }
    }
  };

  var statistics = {
    runNumber: 1,
    currentScore: 0,
    currentMoveCount: 0,
    meanScore: null,
    meanMoveCount: null,
    winCount: 0,

    display() {
      document.getElementById('runNumber').innerHTML = this.runNumber;
      document.getElementById('currentScore').innerHTML = this.currentScore;
      document.getElementById('currentMoveCount').innerHTML = this.currentMoveCount;
      document.getElementById('meanScore').innerHTML = this.meanScore;
      document.getElementById('meanMoveCount').innerHTML = this.meanMoveCount;
      if (this.runNumber > 1) {
        document.getElementById('winRate').innerHTML = this.winCount * 100 / (this.runNumber - 1) + "%";
      }
    },

    refresh() {
      if (this.runNumber === 1) {
        this.meanScore = this.currentScore;
        this.meanMoveCount = this.currentMoveCount;
      } else {
        this.meanScore = (this.meanScore * this.runNumber + this.currentScore) / (this.runNumber + 1);
        this.meanMoveCount = (this.meanMoveCount * this.runNumber + this.currentMoveCount) / (this.runNumber + 1);
      }
      this.runNumber++;
      if (this.currentScore === board.size() - 1) {
        this.winCount++;
      }
      this.currentScore = 0;
      this.currentMoveCount = 0;
    }
  };

  var board = {
    width: 16,
    height: 16,
    map: [],
    fruit: undefined,

    render() {
      var canvasItemWidth = canvas.width / this.width;
      var canvasItemHeight = canvas.height / this.height;

      for (var i = 0; i < this.width; i++) {
        for (var j = 0; j < this.height; j++) {
          switch (this.map[i][j].item) {
            case ITEMS.EMPTY:
              context.clearRect(i * canvasItemWidth, j * canvasItemHeight, canvasItemWidth, canvasItemHeight);
              break;
            case ITEMS.FRUIT:
              context.fillStyle = 'red';
              context.fillRect(i * canvasItemWidth, j * canvasItemHeight, canvasItemWidth, canvasItemHeight);
              break;
            case ITEMS.SNAKE:
              context.fillStyle = 'green';
              context.fillRect(i * canvasItemWidth, j * canvasItemHeight, canvasItemWidth, canvasItemHeight);
              break;
          }
        }
      }
      
      var fontSize = canvasItemHeight / 2;
      context.font = fontSize + 'px courrier';
      if (options.showSnakeIndices) {
        context.fillStyle = 'white';
        for (var i = 0; i < snake.body.length; i++) {
          context.fillText(i, snake.body[i].x * canvasItemWidth, snake.body[i].y * canvasItemHeight + fontSize);
        }
      }
      if (options.showHamiltonianIndices) {
        context.fillStyle = 'grey';
        if (board.map[snake.head().x][snake.head().y].hIndex !== undefined) {
          for (var i = 0; i < board.width; i++) {
            for (var j = 0; j < board.height; j++) {
              context.fillText((board.map[i][j].hIndex === undefined) ? '' : board.map[i][j].hIndex, i * canvasItemWidth, j * canvasItemHeight + 2 * fontSize);
            }
          }
        }
      }
    },

    size() {
      return this.width * this.height;
    },

    clear() {
      for (var i = 0; i < this.width; i++) {
        this.map[i] = [];
        for (var j = 0; j < this.height; j++) {
          this.map[i][j] = { item: ITEMS.EMPTY };
        }
      }
    },

    spawnFruit() {
      var freeBoardCapacity = this.size() - snake.body.length - 1;
      if (freeBoardCapacity < 1) {
        return;
      }
      var probabilityDenominator = freeBoardCapacity;
      for (var i = 0; i < this.width; i++) {
        for (var j = 0; j < this.height; j++) {
          if (this.map[i][j].item === ITEMS.EMPTY) {
            if (Math.floor(Math.random() * Math.floor(--probabilityDenominator)) === 0) {
              this.map[i][j].item = ITEMS.FRUIT;
              this.fruit = { x: i, y: j };
              return;
            }
          }
        }
      }
    }
  }

  var snake = {
    body: undefined,
    direction: undefined,
    collided: undefined,

    start() {
      this.body = [];
      var head = {
        x: Math.floor(board.width / 4) + Math.floor(Math.random() * Math.floor(board.width / 2)),
        y: Math.floor(board.height / 4) + Math.floor(Math.random() * Math.floor(board.height / 2))
      };
      this.body.push(head);
      board.map[head.x][head.y].item = ITEMS.SNAKE;

      this.direction = [DIRECTIONS.LEFT, DIRECTIONS.RIGHT, DIRECTIONS.UP, DIRECTIONS.DOWN][Math.floor(Math.random() * 4)];
      this.collided = false;
    },

    decide() {
      if (options.player !== 'ai') {
        return;
      }

      //the snake length needs to be at least 2 to compute the longest path to the tail end
      var shortestPathToFruit = ai.shortestPathTo(board.fruit);
      if (this.body.length < 2) {
        this.direction = shortestPathToFruit[0];
        return;
      }

      //the Hamiltonian circuit is the guaranteed safe path
      if (board.map[this.head().x][this.head().y].hIndex === undefined) {
        ai.buildHamiltonianCycle();
      }
      this.direction = board.map[this.head().x][this.head().y].hDirection;

      //try a shortcut without breaking the Hamiltonian circuit
      if (options.enableHamiltonianShortcuts && snake.body.length < board.size() * 0.5) { 
        var hShortcutToFruit = ai.hamiltonianShortcutTo(board.fruit);
        if (hShortcutToFruit && hShortcutToFruit.length > 0) {
          this.direction = hShortcutToFruit[0];
        }
      }
    },

    listen(event) {
      if (options.player === 'ai') {
        return;
      }

      var previousDirection = snake.direction;
      
      if (event.key === 'a' || event.keyCode === 37) {
        snake.direction = DIRECTIONS.LEFT;
      } else if (event.key === 'd' || event.keyCode === 39) {
        snake.direction = DIRECTIONS.RIGHT;
      } else if (event.key === 'w' || event.keyCode === 38) {
        snake.direction = DIRECTIONS.UP;
      } else if (event.key === 's' || event.keyCode === 40) {
        snake.direction = DIRECTIONS.DOWN;
      }

      if (snake.direction === utility.opposite(previousDirection)) {
        snake.direction = previousDirection;
      }
    },

    move() {
      var nextHead = { x: this.head().x, y: this.head().y };
      nextHead.x += this.direction.x;
      nextHead.y += this.direction.y;

      if (this.collides(nextHead)) {
        this.collided = true;
        return;
      }

      if (board.map[nextHead.x][nextHead.y].item === ITEMS.FRUIT) {
        statistics.currentScore++;
        board.spawnFruit();
      } else {
        var previousTailEnd = this.body.pop();
        board.map[previousTailEnd.x][previousTailEnd.y].item = ITEMS.EMPTY;
      }

      this.body.unshift(nextHead);
      board.map[nextHead.x][nextHead.y].item = ITEMS.SNAKE;

      statistics.currentMoveCount++;
    },

    collides(position) {
      return position.x < 0 || position.x > board.width - 1 || position.y < 0 || position.y > board.height - 1
        // || snake.body.length > 1 && (position.x === this.head().x + utility.opposite(this.direction).x)
        //   && (position.y === this.head().y + utility.opposite(this.direction).y)
        || board.map[position.x][position.y].item === ITEMS.SNAKE //auto-collision except when the heads runs into the end of the tail
        && (position.x !== this.tailEnd().x || position.y !== this.tailEnd().y);
    },

    wins() {
      return this.body.length === board.size();
    },

    head() {
      return this.body[0];
    },

    tailEnd() {
      return this.body[this.body.length - 1];
    }
  };

  var ai = {
    bestPath: undefined,

    //based on https://en.wikipedia.org/wiki/Breadth-first_search
    shortestPathTo(destination, hamiltonian) {
      var visited = new Set();

      var queue = [];
      queue.push({ position: { x: snake.head().x, y: snake.head().y }, path: [], cost: 0 });
      while (queue.length > 0) {
        var current = queue.shift();
        if (current.position.x === destination.x && current.position.y === destination.y) {
          return current.path;
        }
        if (!visited.has(current.position.x + '-' + current.position.y)) {
          visited.add(current.position.x + '-' + current.position.y);

          var directions = [DIRECTIONS.LEFT, DIRECTIONS.RIGHT, DIRECTIONS.UP, DIRECTIONS.DOWN];
          utility.shuffle(directions);
          for (var i = 0; i < directions.length; i++) {
            var direction = directions[i];
            var next = { x: current.position.x + direction.x, y: current.position.y + direction.y };
            if (!snake.collides(next) && (!hamiltonian || board.map[current.position.x][current.position.y].hIndex < board.map[next.x][next.y].hIndex
              || board.map[current.position.x][current.position.y].hIndex === board.size() - 1)) {
              queue.push({ position: next, path: current.path.concat([direction]), cost: current.cost + 1 });
            }
          }
        }
      }
    },

    //extension of the shortest path until all positions are visited
    longestPathTo(destination) {
      var path = this.shortestPathTo(destination);
      if (path && path.length > 0) {
        var visited = new Set();
        var current = { x: snake.head().x, y: snake.head().y };
        visited.add(current.x + '-' + current.y);
        for (var i = 0; i < path.length; i++) {
          var direction = path[i]
          current = { x: current.x + direction.x, y: current.y + direction.y };
          visited.add(current.x + '-' + current.y);
        }

        var current = { x: snake.head().x, y: snake.head().y };
        for (var i = 0; i < path.length;) {
          var direction = path[i]
          var next = { x: current.x + direction.x, y: current.y + direction.y };

          var extensions = (direction === DIRECTIONS.LEFT || direction === DIRECTIONS.RIGHT)
            ? [DIRECTIONS.UP, DIRECTIONS.DOWN] : [DIRECTIONS.LEFT, DIRECTIONS.RIGHT];
          utility.shuffle(extensions);

          var extended = false;
          for (var j = 0; j < extensions.length; j++) {
            var extension = extensions[j];
            extendedCurrent = { x: current.x + extension.x, y: current.y + extension.y };
            extendedNext = { x: next.x + extension.x, y: next.y + extension.y };

            if (!visited.has(extendedCurrent.x + '-' + extendedCurrent.y) && !snake.collides(extendedCurrent)
              && !visited.has(extendedNext.x + '-' + extendedNext.y) && !snake.collides(extendedNext)) {
              visited.add(extendedCurrent.x + '-' + extendedCurrent.y);
              visited.add(extendedNext.x + '-' + extendedNext.y);

              path.splice(i, 0, extension);

              var oppositeExtension = utility.opposite(extension);
              path.splice(i + 2, 0, oppositeExtension);

              extended = true;
              break;
            }
          }
          if (!extended) {
            current = next;
            i++;
          }
        }
      }
      return path;
    },

    //see https://en.wikipedia.org/wiki/Hamiltonian_path
    buildHamiltonianCycle() {
      for (var i = 0; i < board.width; i++) {
        for (var j = 0; j < board.height; j++) {
          board.map[i][j].hIndex = undefined;
          board.map[i][j].hDirection = undefined;
        }
      }

      var path = this.longestPathTo(snake.tailEnd());
      if (path && path.length > 0) {
        var index = 0;
        var current = { x: snake.head().x, y: snake.head().y };
        
        for (var i = 0; i < path.length; i++) {
          var direction = path[i];

          board.map[current.x][current.y].hIndex = index++;
          board.map[current.x][current.y].hDirection = direction;

          current = { x: current.x + direction.x, y: current.y + direction.y };
        }
        
        for (var i = snake.body.length - 1; i >= 1; i--) {
          var current = snake.body[i];
          var next = snake.body[i - 1];
          var direction = (next.x < current.x) ? DIRECTIONS.LEFT : (next.x > current.x) ? DIRECTIONS.RIGHT
            : (next.y < current.y) ? DIRECTIONS.UP : DIRECTIONS.DOWN;

          board.map[current.x][current.y].hIndex = index++;
          board.map[current.x][current.y].hDirection = direction;
        }
      }

      //retry until the circuit fully covers the map (thanks to the shuffle)
      if (index < board.size() - 1) {
        this.buildHamiltonianCycle();
      }
    },

    hamiltonianShortcutTo(position) {
      if (board.map[snake.head().x][snake.head().y].hIndex === undefined) {
        return;
      }

      var shortcut = ai.shortestPathTo(position, 'hamiltonian');
      if (shortcut && shortcut.length > 0) {
        var newSnake = [];
        for (var i = 0; i < snake.body.length; i++) {
          newSnake.push(snake.body[i]);
        }

        for (var i = 0; i < shortcut.length; i++) {
          var newSnakeIndices = [];
          for (var j = 0; j < snake.body.length - 1; j++) {
            newSnakeIndices.push(board.map[newSnake[j].x][newSnake[j].y].hIndex);
          }

          var next = { x: newSnake[0].x + shortcut[i].x, y: newSnake[0].y + shortcut[i].y };
          if (Math.min(...newSnakeIndices) <= board.map[next.x][next.y].hIndex && board.map[next.x][next.y].hIndex <= Math.max(...newSnakeIndices)) {
            return;
          }

          newSnake.unshift(next);
          newSnake.pop();
        }
        return shortcut;
      }
    }
  };

  var utility = {
    shuffle(array) {
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    },

    opposite(direction) {
      return (direction === DIRECTIONS.LEFT) ? DIRECTIONS.RIGHT
        : (direction === DIRECTIONS.RIGHT) ? DIRECTIONS.LEFT
          : (direction === DIRECTIONS.UP) ? DIRECTIONS.DOWN : DIRECTIONS.UP;
    }
  };

  const ITEMS = {
    EMPTY: 0,
    FRUIT: 1,
    SNAKE: 2
  };

  const DIRECTIONS = {
    LEFT: { x: -1, y: 0 },
    RIGHT: { x: 1, y: 0 },
    UP: { x: 0, y: -1 },
    DOWN: { x: 0, y: 1 }
  };
</script>

</html>